using System;

namespace SetOperations
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] U = new int[100]; // Giả sử tập vũ trụ có tối đa 100 phần tử
            int[] A = new int[100];
            int[] B = new int[100];

            NhapTapHop(U, "Tập vũ trụ U");
            NhapTapHop(A, "Tập A");
            NhapTapHop(B, "Tập B");

            // Phần còn lại tương tự như code sử dụng HashSet
            // ...
        }

        static void NhapTapHop(int[] set, string tenTap)
        {
            Console.WriteLine($"Nhập các phần tử của {tenTap} (nhập -1 để kết thúc):");
            int i = 0;
            int n;
            while ((n = int.Parse(Console.ReadLine())) != -1)
            {
                if (!KiemTraTonTai(set, n, i))
                {
                    set[i++] = n;
                }
            }
        }

        static bool KiemTraTonTai(int[] arr, int x, int n)
        {
            for (int i = 0; i < n; i++)
            {
                if (arr[i] == x)
                {
                    return true;
                }
            }
            return false;
        }

        static void SapXep(int[] arr, int n)
        {
            // Sử dụng thuật toán sắp xếp nổi bọt (bạn có thể thay thế bằng các thuật toán khác)
            for (int i = 0; i < n - 1; i++)
            {
                for (int j = 0; j < n - i - 1; j++)
                {
                    if (arr[j] > arr[j + 1])
                    {
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
        }

        static void TinhGiao(int[] A, int[] B, int nA, int nB, out int[] giao, out int nGiao)
        {
            SapXep(A, nA);
            SapXep(B, nB);

            ngiao = new int[Math.Min(nA, nB)];
            nGiao = 0;
            int i = 0, j = 0;
            while (i < nA && j < nB)
            {
                if (A[i] == B[j])
                {
                    giao[nGiao++] = A[i];
                    i++;
                    j++;
                }
                else if (A[i] < B[j])
                {
                    i++;
                }
                else
                {
                    j++;
                }
            }
        }

        static void TinhHop(int[] A, int[] B, int nA, int nB, out int[] hop, out int nHop)
        {
            hop = new int[nA + nB]; // Tối đa các phần tử trong hợp bằng tổng số phần tử của A và B
            nHop = 0;
            for (int i = 0; i < nA; i++)
            {
                hop[nHop++] = A[i];
            }
            for (int i = 0; i < nB; i++)
            {
                if (!KiemTraTonTai(hop, B[i], nHop))
                {
                    hop[nHop++] = B[i];
                }
            }
        }

        static void TinhHieu(int[] A, int[] B, int nA, int nB, out int[] hieu, out int nHieu)
        {
            hieu = new int[nA];
            nHieu = 0;
            for (int i = 0; i < nA; i++)
            {
                if (!KiemTraTonTai(B, A[i], nB))
                {
                    hieu[nHieu++] = A[i];
                }
            }
        }

        static void TinhPhanBu(int[] U, int[] A, int nU, int nA, out int[] phanBu, out int nPhanBu)
        {
            phanBu = new int[nU];
            nPhanBu = 0;
            for (int i = 0; i < nU; i++)
            {
                if (!KiemTraTonTai(A, U[i], nA))
                {
                    phanBu[nPhanBu++] = U[i];
                }
            }
        }

        static void TinhHieuDoiXung(int[] A, int[] B, int nA, int nB, out int[] hieuDoiXung, out int nHieuDoiXung)
        {
            // Tính hiệu A\B và B\A, sau đó hợp hai hiệu lại
            int[] hieuAB, hieuBA;
            int nHieuAB, nHieuBA;
            TinhHieu(A, B, nA, nB, out hieuAB, out nHieuAB);
            TinhHieu(B, A, nB, nA, out hieuBA, out nHieuBA);
            TinhHop(hieuAB, hieuBA, nHieuAB, nHieuBA, out hieuDoiXung, out nHieuDoiXung);
        }
    }
}
